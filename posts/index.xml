<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on /home/bourbon</title>
    <link>https://crystalsage.github.io/posts/</link>
    <description>Recent content in Posts on /home/bourbon</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>Licensed to Bourbon</copyright>
    <lastBuildDate>Sun, 20 Feb 2022 00:00:00 +0000</lastBuildDate><atom:link href="https://crystalsage.github.io/posts/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>CSI-CTF Writeup (Part-2)</title>
      <link>https://crystalsage.github.io/posts/ctf-2/</link>
      <pubDate>Sun, 20 Feb 2022 00:00:00 +0000</pubDate>
      
      <guid>https://crystalsage.github.io/posts/ctf-2/</guid>
      <description>This is the part 2 of the 3-part series for the CSI-CTF writeup. Click Here to read the 1st part.
You can register and play this CTF. It&amp;rsquo;s open to everyone.
In this 3-part series, we will see my method of approaching these challenges and how I solved them. The 9 challenges are divided into 3 posts.
Attack on Bank The challenge description gives us info about the encrypted text (Also notice how ECB abbreviation gives us a hint about 128-bit AES-ECB being the cryptosystem).</description>
      <content>&lt;p&gt;This is the part 2 of the 3-part series for the CSI-CTF writeup. Click
&lt;a href=&#34;https://crystalsage.github.io/posts/ctf-1/&#34;&gt;Here&lt;/a&gt; to read the 1st part.&lt;/p&gt;
&lt;p&gt;You can &lt;a href=&#34;https://tinyurl.com/2t6kwcxe&#34;&gt;register&lt;/a&gt; and
&lt;a href=&#34;https://tinyurl.com/ms95pajv&#34;&gt;play&lt;/a&gt; this CTF. It&amp;rsquo;s open to everyone.&lt;/p&gt;
&lt;p&gt;In this 3-part series, we will see my method of approaching these challenges
and how I solved them. The 9 challenges are divided into 3 posts.&lt;/p&gt;
&lt;h1 id=&#34;attack-on-bank&#34;&gt;Attack on Bank&lt;/h1&gt;
&lt;p&gt;&lt;img src=&#34;https://crystalsage.github.io/ctf/AOB.png&#34; alt=&#34;here&#34;&gt;&lt;/p&gt;
&lt;p&gt;The challenge description gives us info about the encrypted text (Also notice
how ECB abbreviation gives us a hint about 128-bit AES-ECB being the cryptosystem).
We also get an unique ID for the bank, which should be the decryption key, if my guess is correct.&lt;/p&gt;
&lt;p&gt;The link given in the challenge leads us to a Paste(bin) where we can find some encrypted text, encoded in base64: &lt;code&gt;Keg7B3p7TENwcvdk2zsy+NXVQzMnMxg6ik2xO0M6A3c=&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;Cool. This is easy. We can use what we assume to be the key as the key, and
decrypt the text. I used my favorite tool, &lt;a href=&#34;https://gchq.github.io/CyberChef/&#34;&gt;CyberChef&lt;/a&gt;
for this.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://crystalsage.github.io/ctf/aob-flag.png&#34; alt=&#34;aob-flag&#34;&gt;&lt;/p&gt;
&lt;p&gt;We first decoded the base64 encoded plaintext, and decrypted the text using the
key, and a blank IV. This gets us our flag! &lt;code&gt;csi-ctf{pR0videncE_$4ys_He110}&lt;/code&gt;&lt;/p&gt;
&lt;h1 id=&#34;js-nerds&#34;&gt;JS Nerds&lt;/h1&gt;
&lt;p&gt;&lt;img src=&#34;https://crystalsage.github.io/ctf/jsn.png&#34; alt=&#34;jsn&#34;&gt;&lt;/p&gt;
&lt;p&gt;We get login page right off the bat. I was initially thrown off by the obvious
hints towards a Blind SQL injection. &lt;em&gt;You can&amp;rsquo;t see me&lt;/em&gt; is really
suggestive. To test this if there&amp;rsquo;s any SQLi involved at all,
I used typical payloads such as &lt;code&gt;&#39; OR 1=1 --&lt;/code&gt; and friends.
But this yielded nothing even after 5-6 minutes of trying, so I eventually gave up on this.&lt;/p&gt;
&lt;p&gt;If we visit this page&amp;rsquo;s source, we can find a file at the bottom named
&lt;code&gt;index.js&lt;/code&gt; referenced in there. This &lt;code&gt;index.js&lt;/code&gt; file contains some Javascript
code.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;function&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;checkData&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;event&lt;/span&gt;) {
    &lt;span style=&#34;color:#a6e22e&#34;&gt;console&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;log&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;click&amp;#34;&lt;/span&gt;);
    &lt;span style=&#34;color:#a6e22e&#34;&gt;event&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;preventDefault&lt;/span&gt;();
    &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;x&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; document.&lt;span style=&#34;color:#a6e22e&#34;&gt;forms&lt;/span&gt;[&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;login-form&amp;#34;&lt;/span&gt;][&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;username&amp;#34;&lt;/span&gt;].&lt;span style=&#34;color:#a6e22e&#34;&gt;value&lt;/span&gt;;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;p&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; document.&lt;span style=&#34;color:#a6e22e&#34;&gt;forms&lt;/span&gt;[&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;login-form&amp;#34;&lt;/span&gt;][&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;password&amp;#34;&lt;/span&gt;].&lt;span style=&#34;color:#a6e22e&#34;&gt;value&lt;/span&gt;;
    &lt;span style=&#34;color:#75715e&#34;&gt;// oh no! Client side validation always fails! thank god I have encrypted it!
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (&lt;span style=&#34;color:#a6e22e&#34;&gt;x&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;===&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;John&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;||&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;SHA1&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;p&lt;/span&gt;) &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;b89356ff6151527e89c4f3e3d30c8e6586c63962&amp;#34;&lt;/span&gt;) {;
    } &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt; {
        &lt;span style=&#34;color:#a6e22e&#34;&gt;alert&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Invalid username or password&amp;#34;&lt;/span&gt;);
    }

};
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Oh. We get the username and SHA-1 hash of our password. So I guess we have
to crack SHA-1 now. We can do this using a tool such as hashcat and crack this
password using a wordlist. But I didn&amp;rsquo;t happen to have my machine with me,
so I had to use &lt;a href=&#34;https://crackstation.net/&#34;&gt;crackstation&lt;/a&gt; to do this. Fortunately,
crackstation had this hash in their database, which reveals the password to be
&lt;code&gt;adminz&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://crystalsage.github.io/ctf/jsn-hash.png&#34; alt=&#34;jsn-hash&#34;&gt;&lt;/p&gt;
&lt;p&gt;We can log in to the site with our credentials now to get the flag.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://crystalsage.github.io/ctf/jsn-flag.png&#34; alt=&#34;jsn-flag&#34;&gt;&lt;/p&gt;
&lt;p&gt;Bread! &lt;code&gt;csi-ctf{eXploIted_wEb}&lt;/code&gt;&lt;/p&gt;
&lt;h1 id=&#34;computer-engineering&#34;&gt;Computer Engineering&lt;/h1&gt;
&lt;p&gt;&lt;img src=&#34;https://crystalsage.github.io/ctf/ce1.png&#34; alt=&#34;ce-1&#34;&gt;&lt;/p&gt;
&lt;p&gt;We get another Github page. Except this time, there is nothing in
the 6 commits. We do notice the 6 branches though.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://crystalsage.github.io/ctf/ce2.png&#34; alt=&#34;ce-2&#34;&gt;&lt;/p&gt;
&lt;p&gt;There are 6 branches, let&amp;rsquo;s visit CS first. There are 3 commits in
there, one of which gives us the flag.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://crystalsage.github.io/ctf/ce3.png&#34; alt=&#34;ce-3&#34;&gt;&lt;/p&gt;
&lt;p&gt;Flag! &lt;code&gt;csi-ctf{this_is_the_flag_codecocomo}&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;This challenge was really more of a &amp;ldquo;click 50 times to get the flag&amp;rdquo; challenge.
These types of challenges where flags are hidden in commit histories and
branches are not included &lt;strong&gt;in CTFs&lt;/strong&gt; due to them having less of a problem
solving aspect to them.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;However&lt;/strong&gt;, every often, some company get pwned or a bug hunter gets rewarded
handsomely because he found an internal API key or SSH key in a Github
commit history, which was accidentally pushed to the repo. So, it&amp;rsquo;s not
unrealistic at all. There&amp;rsquo;s a lesson to be learned here.&lt;/p&gt;
&lt;hr style=&#34;border:2px solid gray&#34;&gt; &lt;/hr&gt;
This series is to be continued in part 3 where we&#39;ll solve more
challenges...
</content>
    </item>
    
    <item>
      <title>CSI-CTF Writeup (Part-1)</title>
      <link>https://crystalsage.github.io/posts/ctf-1/</link>
      <pubDate>Sun, 13 Feb 2022 00:00:00 +0000</pubDate>
      
      <guid>https://crystalsage.github.io/posts/ctf-1/</guid>
      <description>I recently won 1st place at the CSI-CTF 2022. The CTF was basic, but still amazing (We find that the two things are often mutually exclusive in many CTFs). The challenges were easy, but not lame. The UI was fantastic. I was impressed by the CTF infrastructure. It is not easy to host a CTF this well.
You can register and play this CTF. It&amp;rsquo;s open to everyone.
In this 3-part series, we will see my method of approaching these challenges and how I solved them.</description>
      <content>&lt;p&gt;I recently won 1st place at the CSI-CTF 2022. The CTF was basic, but still
amazing (We find that the two things are often mutually exclusive in many CTFs).
The challenges were easy, but not lame. The UI was fantastic. I was impressed
by the CTF infrastructure. It is not easy to host a CTF this well.&lt;/p&gt;
&lt;p&gt;You can &lt;a href=&#34;https://tinyurl.com/2t6kwcxe&#34;&gt;register&lt;/a&gt; and
&lt;a href=&#34;https://tinyurl.com/ms95pajv&#34;&gt;play&lt;/a&gt; this CTF. It&amp;rsquo;s open to everyone.&lt;/p&gt;
&lt;p&gt;In this 3-part series, we will see my method of approaching these challenges
and how I solved them. The 9 challenges are divided into 3 posts.
&lt;img src=&#34;https://crystalsage.github.io/ctf.jpg&#34; alt=&#34;Some&#34;&gt;&lt;/p&gt;
&lt;p&gt;A tip for solving easy CTF challenges is that the name of the challenge
often gives a hint to you. After that, you just need to keep your mind open to all
the possibilities and think your way through. Keep the name in the back of
your mind but don&amp;rsquo;t let it bias your thinking. Keep an open approach to any
challenge which you&amp;rsquo;re aiming to solve.&lt;/p&gt;
&lt;h1 id=&#34;what-lies-within&#34;&gt;What Lies Within&lt;/h1&gt;
&lt;p&gt;&lt;img src=&#34;https://crystalsage.github.io/ctf/whatlieswithin.png&#34; alt=&#34;challenge&#34;&gt;
From the challenge&amp;rsquo;s name and some experience, we can immediately guess that the
image has data inside it. The most preliminary test you can do to weed out
some easy challenges is to run &lt;code&gt;strings&lt;/code&gt; on the image. &lt;code&gt;strings&lt;/code&gt; will yield us
the plaintext strings inside the file.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://crystalsage.github.io/ctf/whatlieswithin-strings.png&#34; alt=&#34;wlw-strings&#34;&gt;&lt;/p&gt;
&lt;p&gt;As you can see, it returns us all of the plaintext things inside the image. It
would be a mad task to scroll down and find our flag in this haystack. So, we
can find our flag using &lt;code&gt;grep&lt;/code&gt;. We can grep for the flag&amp;rsquo;s format since we
definitely know it&amp;rsquo;s a part of the flag.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://crystalsage.github.io/ctf/whatlieswithin-flag.png&#34; alt=&#34;flag&#34;&gt;&lt;/p&gt;
&lt;p&gt;The flag! &lt;code&gt;csi-ctf{Let&#39;s_go_to_the_subway_for_lunch}&lt;/code&gt; $\blacksquare$&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&#34;luminous-hunt&#34;&gt;Luminous Hunt&lt;/h1&gt;
&lt;p&gt;&lt;img src=&#34;https://crystalsage.github.io/ctf/lh-chall.png&#34; alt=&#34;lh-chall&#34;&gt;
In this challenge, we are again, starting with an image. And, the name gives
us a hint about this being related to light.&lt;/p&gt;
&lt;p&gt;My initial guess was that the image contained the flag, but it&amp;rsquo;s too small to
see. I &lt;em&gt;really&lt;/em&gt; zoomed in on the image to see if there was a tiny flag somewhere
in there, but nope. Thanks creators for not doing this!
(This is actually a pretty common thing in CTFs!)&lt;/p&gt;
&lt;p&gt;Next, I tried putting this image in an image editor and analyzed its RGB
channels. The flag, if  hidden in one of the three channels, is only visible
in that particular channel. But no.&lt;/p&gt;
&lt;p&gt;I was out of my typical ideas when I enlarged the image a bit and noticed that
the blackboard looked too black. Something seemed off about it. So, keeping the
challenge name and the weird blackboard color in mind, I decided to brighten
up the image, and play around with the contrast, which gives us our flag,
hidden in the darkness of the blackboard.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://crystalsage.github.io/ctf/lh-brighten.png&#34; alt=&#34;lh-brighten&#34;&gt;&lt;/p&gt;
&lt;p&gt;It&amp;rsquo;s still somewhat hard to read, but we can make out &lt;code&gt;csi-ctf{CPL-CSI}&lt;/code&gt;, which
is our flag. $\blacksquare$&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&#34;a-tribute&#34;&gt;A Tribute&lt;/h1&gt;
&lt;p&gt;&lt;img src=&#34;https://crystalsage.github.io/ctf/at-chall.png&#34; alt=&#34;at-chall&#34;&gt;
We are given a GitHub page which tells us to find the name of a person. This
obviously is an OSINT challenge, right? No! There&amp;rsquo;s a twist here.&lt;/p&gt;
&lt;p&gt;If you find out the person&amp;rsquo;s name, and try to submit it as a flag, the
submission gets denied.&lt;/p&gt;
&lt;p&gt;If you take a look around the page, you&amp;rsquo;ll see that the repository&amp;rsquo;s commit
history is pretty interesting. It contains some strings that could be useful
to us.
&lt;img src=&#34;https://crystalsage.github.io/ctf/at-commits.png&#34; alt=&#34;at-commits&#34;&gt;
The letters look jumbled but they are still readable. This is probably encoded
with some cipher. If you&amp;rsquo;ve had any sort of experience with ciphers, you&amp;rsquo;ve
probably heard of the Caesar cipher, AKA rot-n cipher. One of the strings of
the commit messages must be our encoded flag.&lt;/p&gt;
&lt;p&gt;If you patiently try out some/all of these, you&amp;rsquo;ll find out that the 4th commit
message from the top is actually our flag, with rot-18 encoding.
&lt;img src=&#34;https://crystalsage.github.io/ctf/at-flag.png&#34; alt=&#34;at-flag&#34;&gt;&lt;/p&gt;
&lt;p&gt;The flag is &lt;code&gt;csi-ctf{congratulations_the_flag_is_jira}&lt;/code&gt; $\blacksquare$&lt;/p&gt;
&lt;hr style=&#34;border:2px solid gray&#34;&gt; &lt;/hr&gt;
This series is to be continued in the part 2 and 3 where we&#39;ll solve more
challenges...
</content>
    </item>
    
    <item>
      <title>Swallow</title>
      <link>https://crystalsage.github.io/posts/swallow/</link>
      <pubDate>Thu, 13 Jan 2022 00:00:00 +0000</pubDate>
      
      <guid>https://crystalsage.github.io/posts/swallow/</guid>
      <description>Throughout the discussion, C-x means Control + x keychord.
Introduction Window swallowing is a mechanism in tiling window managers, by which a GUI application&amp;rsquo;s window can replace the terminal window in-place, when the application is called from the terminal.
This avoids congestion in tiling WMs, and is a much preferred solution than zooming into the said GUI window (Also called monocle mode in some WMs)
For instance, consider a scenario where I want to spawn VLC from my terminal.</description>
      <content>&lt;p&gt;Throughout the discussion, &lt;code&gt;C-x&lt;/code&gt; means Control + x keychord.&lt;/p&gt;
&lt;h1 id=&#34;introduction&#34;&gt;Introduction&lt;/h1&gt;
&lt;p&gt;Window swallowing is a mechanism in tiling window managers, by which a GUI application&amp;rsquo;s window can replace the terminal window in-place, when the application is called from the terminal.&lt;/p&gt;
&lt;p&gt;This avoids congestion in tiling WMs, and is a much preferred solution than zooming into the said GUI window (Also called &lt;em&gt;monocle mode&lt;/em&gt; in some WMs)&lt;/p&gt;
&lt;p&gt;For instance, consider a scenario where I want to spawn VLC from my terminal. After I call VLC with &lt;code&gt;vlc ./video.mp4&lt;/code&gt;, I get a VLC window on my screen. But now, there&amp;rsquo;s a leftover terminal window that does nothing, and you can&amp;rsquo;t close it because it&amp;rsquo;s the parent window of VLC.&lt;sup id=&#34;fnref:1&#34;&gt;&lt;a href=&#34;#fn:1&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;
&lt;p&gt;The following diagram illustrates the difference without and with swallowing, respectively:
&lt;img src=&#34;https://crystalsage.github.io/swallow.png&#34; alt=&#34;Swallow_VLC&#34;&gt;&lt;/p&gt;
&lt;p&gt;Popular WMs such as DWM, BSPWM and i3 have patches available for swallowing a window. However, I prefer a native solution over patches. As a bonus, the solution that I was able to come up with is also universal.&lt;/p&gt;
&lt;h1 id=&#34;my-solution&#34;&gt;My solution&lt;/h1&gt;
&lt;p&gt;My solution, whether if inefficient or dumb, most importantly works and has never failed me.&lt;/p&gt;
&lt;p&gt;I combine a BASH script + a Fish shell function (alias) + a Fish shell keyboard shortcut that swallows a window. Code explained below. Please don&amp;rsquo;t mind the names.&lt;/p&gt;
&lt;h2 id=&#34;bash-script-rbgsh&#34;&gt;Bash script: &lt;code&gt;rbg.sh&lt;/code&gt;&lt;/h2&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#!/bin/sh
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;
$@ &amp;amp;
disown
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;This is just doing automatically the stuff that would require manual efforts. The first line takes in the entire &lt;code&gt;argv&lt;/code&gt;, symbolized with &lt;code&gt;@&lt;/code&gt; variable, puts it in background with &lt;code&gt;&amp;amp;&lt;/code&gt; and disowns it.&lt;/p&gt;
&lt;p&gt;The script is meant to be placed in one of the directories in your &lt;code&gt;$PATH&lt;/code&gt;.&lt;/p&gt;
&lt;h2 id=&#34;fish-function-sdffish&#34;&gt;Fish function: &lt;code&gt;sdf.fish&lt;/code&gt;&lt;/h2&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;function&lt;/span&gt; sdf
  rbg $argv &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; exit
end
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Which calls the &lt;code&gt;rbg&lt;/code&gt; binary with your command.&lt;/p&gt;
&lt;p&gt;This function allows us to wrap over the &lt;code&gt;rbg.sh&lt;/code&gt; script as well as close the actual terminal window. This only exists because I couldn&amp;rsquo;t find a way to both exit the BASH script and close the terminal window without messing with Xorg tools.&lt;/p&gt;
&lt;h2 id=&#34;fish-shortcut-goes-in-configfish&#34;&gt;Fish shortcut: goes in &lt;code&gt;config.fish&lt;/code&gt;&lt;/h2&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;bind &lt;span style=&#34;color:#ae81ff&#34;&gt;\c&lt;/span&gt;s &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;fish_commandline_prepend sdf&amp;#39;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Which just prepends &lt;code&gt;sdf&lt;/code&gt; to your command in the terminal. Note that typing &lt;code&gt;sdf &amp;lt;command&amp;gt;&lt;/code&gt; is kind of awkward and feels unnatural (I always forget to do it), so typing the command first and prepending is the most natural flow.&lt;/p&gt;
&lt;h1 id=&#34;results&#34;&gt;Results&lt;/h1&gt;
&lt;p&gt;Now, when I type &lt;code&gt;vlc ./video.mp4&lt;/code&gt; and press &lt;code&gt;C-s&lt;/code&gt; the resulting command becomes &lt;code&gt;sdf vlc ./video.mp4&lt;/code&gt;, which successfully swallows the terminal when executed. It&amp;rsquo;s instantaneous with really no lag.&lt;/p&gt;
&lt;section class=&#34;footnotes&#34; role=&#34;doc-endnotes&#34;&gt;
&lt;hr&gt;
&lt;ol&gt;
&lt;li id=&#34;fn:1&#34; role=&#34;doc-endnote&#34;&gt;
&lt;p&gt;You can close the window by putting the process to background, disowning it and then closing the terminal. The problem with this approach is that it is slow and just doesn&amp;rsquo;t feel right.&amp;#160;&lt;a href=&#34;#fnref:1&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/section&gt;
</content>
    </item>
    
    <item>
      <title>ls clone using getdents syscall</title>
      <link>https://crystalsage.github.io/posts/fp/</link>
      <pubDate>Mon, 15 Nov 2021 18:20:39 +0530</pubDate>
      
      <guid>https://crystalsage.github.io/posts/fp/</guid>
      <description>Introduction In this short post, we’re building a barebones,toy implementation of the ls-like directory listing program in x86-64 assembly. We achieve this by using the getdents syscall.
getdents() syscall The getdents syscall takes in 3 parameters. So the prototype of the syscall looks like: ssize_t getdents(int fd, void *dirp, size_t count), where:
 fd : is the file descriptor of the directory (which is also just another file in Unix) dirp : is where all the dirent structs are copied during the syscall.</description>
      <content>&lt;h1 id=&#34;introduction&#34;&gt;Introduction&lt;/h1&gt;
&lt;p&gt;In this short post, we’re building a barebones,toy implementation of the &lt;code&gt;ls&lt;/code&gt;-like directory listing program in x86-64 assembly. We achieve this by using the &lt;code&gt;getdents&lt;/code&gt; syscall.&lt;/p&gt;
&lt;h1 id=&#34;getdents-syscall&#34;&gt;getdents() syscall&lt;/h1&gt;
&lt;p&gt;The &lt;code&gt;getdents&lt;/code&gt; syscall takes in 3 parameters. So the prototype of the syscall looks like: &lt;code&gt;ssize_t getdents(int fd, void *dirp, size_t count)&lt;/code&gt;, where:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;fd&lt;/code&gt; : is the file descriptor of the directory (which is also just another file in Unix)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;dirp&lt;/code&gt; : is where all the &lt;code&gt;dirent&lt;/code&gt; structs are copied during the syscall.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;count&lt;/code&gt; : is the size of the buffer that &lt;code&gt;dirp&lt;/code&gt; points to.&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;dirent-structs&#34;&gt;Dirent structs&lt;/h1&gt;
&lt;p&gt;A &lt;em&gt;dirent&lt;/em&gt; or &lt;em&gt;linux_dirent&lt;/em&gt; struct is defined as follows.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;struct&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;linux_dirent&lt;/span&gt; {
       &lt;span style=&#34;color:#66d9ef&#34;&gt;unsigned&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;long&lt;/span&gt;  d_ino;     &lt;span style=&#34;color:#75715e&#34;&gt;/* File inode*/&lt;/span&gt;
       &lt;span style=&#34;color:#66d9ef&#34;&gt;unsigned&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;long&lt;/span&gt;  d_off;     &lt;span style=&#34;color:#75715e&#34;&gt;/* Offset of the next linux_dirent */&lt;/span&gt;
       &lt;span style=&#34;color:#66d9ef&#34;&gt;unsigned&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;short&lt;/span&gt; d_reclen;  &lt;span style=&#34;color:#75715e&#34;&gt;/* Size of the current dirent struct*/&lt;/span&gt;
       &lt;span style=&#34;color:#66d9ef&#34;&gt;char&lt;/span&gt;           d_name[];  &lt;span style=&#34;color:#75715e&#34;&gt;// The filename of the file
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;
       &lt;span style=&#34;color:#66d9ef&#34;&gt;char&lt;/span&gt;           pad;       &lt;span style=&#34;color:#75715e&#34;&gt;// Zero padding byte
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;       &lt;span style=&#34;color:#66d9ef&#34;&gt;char&lt;/span&gt;           d_type;    &lt;span style=&#34;color:#75715e&#34;&gt;// File types such as block devices, named pipes, sockets etc.
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;   }

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;So anytime we call the &lt;code&gt;getdents&lt;/code&gt; syscall, we are populating with &lt;code&gt;dirent&lt;/code&gt; structures, the buffer that &lt;code&gt;dirp&lt;/code&gt; points to. Notice how the struct also involves the filename of the file that the struct is for. We can use this for directory listing!&lt;/p&gt;
&lt;h1 id=&#34;the-program&#34;&gt;The program&lt;/h1&gt;
&lt;p&gt;The program that we are building lists the directory contents of the current directory. We allocate a 512 bytes buffer for storing the dirent structs. (Which is sufficient for a toy implementation)&lt;/p&gt;
&lt;p&gt;Based on the info above, we define the &lt;code&gt;.bss&lt;/code&gt; and the &lt;code&gt;.data&lt;/code&gt; sections as follows:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code class=&#34;language-x86asm&#34; data-lang=&#34;x86asm&#34;&gt;[SECTION .data]
dirname: db &#39;.&#39;

[SECTION .bss]
msgbuf:
	resb 512
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Then in the &lt;code&gt;.text&lt;/code&gt; section, we write the actual program, which consists of 2 functions called &lt;code&gt;main&lt;/code&gt; and &lt;code&gt;next_dirent&lt;/code&gt;. We populate the &lt;code&gt;msgbuf&lt;/code&gt; in the &lt;code&gt;main&lt;/code&gt; function and then process the dirent structs in the &lt;code&gt;next_dirent&lt;/code&gt; function, which handles the buffer struct by struct.&lt;/p&gt;
&lt;p&gt;The &lt;code&gt;main&lt;/code&gt; function goes like:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code class=&#34;language-x86asm&#34; data-lang=&#34;x86asm&#34;&gt;[SECTION .text]
extern puts
global main

main:
	;Setup
	push rbp
	mov rbp, rsp
	and rsp, 0xfffffffffffffff0

	;Open the current directory using the open() syscall
	mov rax, 2
	mov rdi, dirname
	mov rsi, 0x10000
	syscall

	;getdents(fd, buf, 64) syscall
	mov rdi, rax  ;The open syscall returns the fd for the current directory
	mov rax,78
	mov rsi, msgbuf
	mov rdx, 512
	syscall
	xchg rax,rdx  ;Syscall returns total size, save it somewhere safe

	;setup registers for loop
	xor rcx, rcx
	xor rbx, rbx
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Now that we have the structs we need in the &lt;code&gt;msgbuf&lt;/code&gt;, we can iterate over them. Heading into the &lt;code&gt;next_dirent&lt;/code&gt; function:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code class=&#34;language-x86asm&#34; data-lang=&#34;x86asm&#34;&gt;next_dirent:
	;We move to the 0th position of msgbuf every loop
	;and absolute position of every struct from it
	mov rax, msgbuf
	add rax, rcx		

	;Grab the length of current struct
	;i.e reclen with offset adjustments
	add rax, 0x10
	movzx bx, byte [rax]

	;puts modifies state of registers so save
	;them on the stack
	push rcx
	push rdx

	;Grab filename from its offset and print it
	;to stdout
	add rax, 0x2
	mov rdi, rax
	call puts

	;Restore register states
	pop rdx				
	pop rcx

	;Move to next struct if
	;index(curr_struct) &amp;lt; total structs
	add cx, bx			
	cmp cx, dx			
	jl next_dirent

	;Leave
	mov rsp, rbp
	pop rbp
	ret
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Offset calculation is:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The struct size sits at &lt;code&gt;struct_index + 8*2 = 0x10&lt;/code&gt; bytes. 2 &lt;code&gt;unsigned long&lt;/code&gt;s are considered for.&lt;/li&gt;
&lt;li&gt;The filename sits at &lt;code&gt;struct_index + 8*2 + 2 = 0x12&lt;/code&gt;bytes. 1 &lt;code&gt;unsigned short&lt;/code&gt; is considered for. Note that we just add &lt;code&gt;0x2&lt;/code&gt; to the struct size offset when outputting the filename.&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;results&#34;&gt;Results&lt;/h1&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&amp;gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&amp;gt; ls
file1.txt  file2.txt  main
&amp;gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&amp;gt; ./main
.
file2.txt
main
..
file1.txt
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Thus we get a barebones directory listing.&lt;/p&gt;
&lt;p&gt;The compile script and code is available : &lt;a href=&#34;https://github.com/CrystalSage/Direntries&#34;&gt;Here&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&#34;ps&#34;&gt;P.S&lt;/h1&gt;
&lt;p&gt;I originally intended to write some malware in assembly with this, but got sidetracked and this was made ;)&lt;/p&gt;
</content>
    </item>
    
  </channel>
</rss>
